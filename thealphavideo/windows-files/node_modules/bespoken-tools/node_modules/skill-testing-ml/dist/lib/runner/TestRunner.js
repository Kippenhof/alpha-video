function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _ = require("lodash");

var chalk = require("chalk");

var Configuration = require("./Configuration");

var CONSTANTS = require("../util/Constants");

var FrameworkError = require("../util/FrameworkError");

var fs = require("fs");

var HTTP = require("../util/HTTP");

var InteractionResult = require("../test/TestResult").InteractionResult;

var LoggingErrorHelper = require("../util/LoggingErrorHelper");

var SmapiError = require("../util/SmapiError");

var TestParser = require("../test/TestParser");

var TestResult = require("../test/TestResult").TestResult;

var url = require("url");

var Util = require("../util/Util");

module.exports = /*#__PURE__*/function () {
  _createClass(TestRunner, null, [{
    key: "removeConfigurationCache",
    value: function removeConfigurationCache() {
      Configuration.reset();
    }
  }]);

  function TestRunner(config) {
    _classCallCheck(this, TestRunner);

    this._config = config;
    this._subscribers = {
      message: [],
      result: []
    };
  }

  _createClass(TestRunner, [{
    key: "run",
    value: function () {
      var _run = _asyncToGenerator(function* (testFile, context) {
        var _this = this;

        return new Promise((resolve, reject) => {
          fs.readFile(testFile, "utf8", /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(function* (error, data) {
              if (error) {
                reject(error);
              }

              try {
                // This may have already been called, but needs to be called again inside of the Jest runner
                yield Configuration.configure(_this._config);

                var testSuite = _this.parseContents(testFile, data);

                resolve(yield _this.runSuite(testSuite, context));
              } catch (e) {
                LoggingErrorHelper.error("bst-test", "Error using bst-test on Node: " + process.version);
                LoggingErrorHelper.error("bst-test", e.stack);
                reject(e);
              }
            });

            return function (_x3, _x4) {
              return _ref.apply(this, arguments);
            };
          }());
        });
      });

      function run(_x, _x2) {
        return _run.apply(this, arguments);
      }

      return run;
    }()
  }, {
    key: "runSuite",
    value: function () {
      var _runSuite = _asyncToGenerator(function* (testSuite, context) {
        // This may have already been called, but needs to be called again inside of the Jest runner
        yield Configuration.configure(this._config);
        yield testSuite.loadLocalizedValues();
        var locales = ["sms", "whatsapp"].includes(testSuite.platform) ? "en-US" : testSuite.locales; // locales now include locales and locale, if property not present we throw the framework error

        if (locales) {
          var localesList = locales.split(",").map(l => l.trim());
          var results = [];

          for (var i = 0; i < localesList.length; i++) {
            results.push(yield this.runSuiteForLocale(testSuite, context, localesList[i]));
          }

          results = [].concat.apply([], results);
          return results;
        } else {
          throw new FrameworkError("Locale must be defined either in the testing.json or the test file itself under the config element");
        }
      });

      function runSuite(_x5, _x6) {
        return _runSuite.apply(this, arguments);
      }

      return runSuite;
    }()
  }, {
    key: "runSuiteForLocale",
    value: function () {
      var _runSuiteForLocale = _asyncToGenerator(function* (testSuite, context, locale) {
        if (!locale) {
          throw new FrameworkError("Locale must be defined either in the testing.json or the test file itself under the config element");
        }

        var testSuiteWithLocale = _.cloneDeep(testSuite);

        testSuiteWithLocale.currentLocale = locale;
        this.replaceLocalizedValues(testSuiteWithLocale);

        if (testSuiteWithLocale.filterObject() && testSuiteWithLocale.filterObject().onTestSuiteStart) {
          yield testSuiteWithLocale.filterObject().onTestSuiteStart(testSuiteWithLocale);
        }

        var invokerName = this.getInvoker(testSuite);

        var InvokerClass = require("./" + invokerName);

        var invoker = new InvokerClass(this);

        try {
          yield invoker.before(testSuiteWithLocale);
        } catch (error) {
          this.emit("result", error);
          throw error;
        }

        var batchEnabled = testSuiteWithLocale.batchEnabled;
        var asyncMode = testSuiteWithLocale.asyncMode;
        testSuiteWithLocale.processIncludedAndExcludedTags();
        testSuiteWithLocale.processOnlyFlag();
        var testResults = [];

        if (testSuite.hasDeprecatedOperators) {
          // eslint-disable-next-line no-console
          console.log(chalk.yellow("WARNING: == and =~ operators are no longer supported, use \":\" instead"));
        }

        if (testSuite.type !== "unit" && testSuite.hasDeprecatedE2EOperators) {
          // eslint-disable-next-line no-console
          console.log(chalk.yellow("WARNING: >, >=, < and <= are unit test operators only"));
        }

        var retryNumberWarning = testSuite.retryNumberWarning;

        if (retryNumberWarning) {
          // eslint-disable-next-line no-console
          console.log(chalk.yellow(retryNumberWarning));
        }

        var getSourceExistPromise = this.getSourceExists(testSuiteWithLocale);
        var startTimeTestSuite = new Date();

        for (var test of testSuiteWithLocale.tests) {
          if (testSuite.filterObject() && testSuite.filterObject().onTestStart) {
            yield testSuite.filterObject().onTestStart(test);
          }

          yield invoker.beforeTest(test);
          var testResult = new TestResult(test);
          testResult.locale = locale;
          testResults.push(testResult);

          if (test.skip) {
            yield invoker.afterTest(test); // if we skip we still need to do the after test in case is closing something like in VGA

            continue;
          }

          if (invoker.batchSupported() && batchEnabled && (test.hasGoto || test.hasExit)) {
            // eslint-disable-next-line no-console
            console.log(chalk.yellow("Warning: \"Goto\" and \"Exit\" functionality are only available when running in sequential mode, set \"batchEnabled\" property to false to enable it"));
          }

          var results = yield this.executeRunWrapper(batchEnabled, asyncMode, invoker, testSuiteWithLocale, test.interactions, context);
          testResult.interactionResults = results;

          if (invoker.currentConversation) {
            testResult.conversationId = invoker.currentConversation;
          }

          yield invoker.afterTest(test);

          if (testSuite.filterObject() && testSuite.filterObject().onTestEnd) {
            yield testSuite.filterObject().onTestEnd(test, testResult);
          }
        }

        yield this.saveTestResults(testResults, testSuiteWithLocale, startTimeTestSuite, getSourceExistPromise);
        yield invoker.after(testSuiteWithLocale);

        if (testSuite.filterObject() && testSuite.filterObject().onTestSuiteEnd) {
          yield testSuite.filterObject().onTestSuiteEnd(testResults);
        }

        return testResults;
      });

      function runSuiteForLocale(_x7, _x8, _x9) {
        return _runSuiteForLocale.apply(this, arguments);
      }

      return runSuiteForLocale;
    }()
  }, {
    key: "executeRunWrapper",
    value: function () {
      var _executeRunWrapper = _asyncToGenerator(function* (batchEnabled, asyncMode, invoker, testSuite, interactions, context) {
        var executionCount = 0;
        var results;

        do {
          if (executionCount > 0) {
            // eslint-disable-next-line no-console
            console.log(chalk.cyan(`Test failed: Retrying ${executionCount}/${testSuite.retryNumber}`));
          }

          results = yield this.executeRun(batchEnabled, asyncMode, invoker, testSuite, interactions, context);
          executionCount++;
        } while (executionCount < testSuite.retryNumber + 1 && results.length > 0 && results.some(result => result.errorOnProcess && result.error.error_code && testSuite.retryOn && testSuite.retryOn.length > 0 && testSuite.retryOn.indexOf(result.error.error_code) > -1));

        return results;
      });

      function executeRunWrapper(_x10, _x11, _x12, _x13, _x14, _x15) {
        return _executeRunWrapper.apply(this, arguments);
      }

      return executeRunWrapper;
    }()
  }, {
    key: "executeRun",
    value: function () {
      var _executeRun = _asyncToGenerator(function* (batchEnabled, asyncMode, invoker, testSuite, interactions, context) {
        // Process through the interactions
        // If there is a goto or this is not a batch invoker, run them one-by-one
        var results;

        if (!(invoker.batchSupported() && batchEnabled)) {
          results = yield this.sequentialRun(invoker, testSuite, interactions, context);
        } else {
          if (invoker.batchSupported() && asyncMode) {
            results = yield this.sequentialRun(invoker, testSuite, interactions, context);
          } else {
            results = yield this.batchRun(invoker, testSuite, interactions, context);
          }
        }

        return results;
      });

      function executeRun(_x16, _x17, _x18, _x19, _x20, _x21) {
        return _executeRun.apply(this, arguments);
      }

      return executeRun;
    }()
  }, {
    key: "batchRun",
    value: function () {
      var _batchRun = _asyncToGenerator(function* (invoker, testSuite, interactions, context) {
        var startTime = new Date();
        var responses = yield invoker.invokeBatch(interactions);
        var endTime = new Date();
        var totalDuration = endTime - startTime;

        if (interactions.length) {
          var avgDuration = Math.floor(totalDuration / interactions.length);
          interactions.forEach(interaction => interaction.duration = avgDuration);
        } // Add short-hand properties to each response


        responses.forEach(response => response.inject()); // Turn the responses into interaction results

        var interactionResults = [];

        for (var i = 0; i < responses.length; i++) {
          var response = responses[i];
          interactionResults.push(yield this.processResponse(response, testSuite, context));
        }

        return interactionResults;
      });

      function batchRun(_x22, _x23, _x24, _x25) {
        return _batchRun.apply(this, arguments);
      }

      return batchRun;
    }()
  }, {
    key: "sequentialRun",
    value: function () {
      var _sequentialRun = _asyncToGenerator(function* (invoker, testSuite, interactions, context) {
        var goto;
        var index = -1;
        var results = [];
        var asyncMode = testSuite.asyncMode;

        for (var interaction of interactions) {
          index++; // If we are in async mode we need to ignore any goto logic
          // If a goto is set, keep skipping until we match it

          if (!asyncMode && goto) {
            if (goto === interaction.utterance || goto == interaction.label) {
              goto = undefined;
            } else {
              continue;
            }
          }

          this.emit("message", undefined, interaction.toDTO(), context);
          var response = void 0;
          var startTime = new Date();

          try {
            response = yield invoker.invoke(interaction, interactions);
            var endTime = new Date();
            interaction.duration = endTime - startTime;

            if (testSuite.trace && index === 0 && invoker.currentConversation) {
              // eslint-disable-next-line no-console
              console.log(chalk.cyan("Conversation id: " + invoker.currentConversation));
            }
          } catch (e) {
            if (!interaction.duration) {
              interaction.duration = new Date() - startTime;
            }

            var resultOnException = this.handleException(interaction, e);
            results.push(resultOnException);
            var interactionDto = interaction.toDTO();
            interactionDto.result = resultOnException.toDTO();
            this.emit("result", undefined, interactionDto, context); // smapi error will stop further interactions

            if (e instanceof SmapiError) {
              break;
            } else {
              continue;
            }
          } // Add short-hand properties to the response


          response.inject();
          var interactionResult = yield this.processResponse(response, testSuite, context); // If we are in async mode we need to ignore any goto logic

          if (!asyncMode && interactionResult.goto) {
            // If this result is a goto, set the goto label
            goto = interactionResult.goto;
          }

          results.push(interactionResult);

          if (!asyncMode && interactionResult.exited) {
            // If this is an exit, stop processing
            break;
          } // break the loop only when the response is empty
          // regards of any error


          if (testSuite.type === CONSTANTS.TYPE.e2e && !response.prompt() && !response.cardTitle() && (response.errorOnProcess || response.isLastItemFromResults)) {
            break;
          }

          if (asyncMode && testSuite.stopTestOnFailure && (interactionResult.error || interactionResult.errors)) {
            invoker.stopProcess && (yield invoker.stopProcess());
            break;
          }
        }

        return results;
      });

      function sequentialRun(_x26, _x27, _x28, _x29) {
        return _sequentialRun.apply(this, arguments);
      }

      return sequentialRun;
    }()
  }, {
    key: "resolveVariablesForAssertionInteraction",
    value: function () {
      var _resolveVariablesForAssertionInteraction = _asyncToGenerator(function* (assertion, localizedValues, resolveMethod) {
        if (!assertion.variables || assertion.variables.length === 0) {
          return localizedValues;
        }

        var _loop = function* (j) {
          var variable = assertion.variables[j];
          var variableValue = yield resolveMethod(variable, assertion.interaction); // Empty values are allowed but undefined means no replacement was found

          if (typeof variableValue == "undefined") {
            return "continue";
          }

          if (Array.isArray(localizedValues)) {
            localizedValues = localizedValues.map(val => {
              return val.split("{" + variable + "}").join(variableValue);
            });
          } else {
            localizedValues = localizedValues.split("{" + variable + "}").join(variableValue);
          }
        };

        for (var j = 0; j < assertion.variables.length; j++) {
          var _ret = yield* _loop(j);

          if (_ret === "continue") continue;
        }

        return localizedValues;
      });

      function resolveVariablesForAssertionInteraction(_x30, _x31, _x32) {
        return _resolveVariablesForAssertionInteraction.apply(this, arguments);
      }

      return resolveVariablesForAssertionInteraction;
    }()
  }, {
    key: "getLocalizedValues",
    value: function () {
      var _getLocalizedValues = _asyncToGenerator(function* (testSuite, assertion) {
        if (Array.isArray(assertion.value)) {
          var localizedValues = [];
          var assertionVariables = new Set();

          for (var value of assertion.value) {
            var localizedValue = testSuite && testSuite.getLocalizedValue(value) || value;
            var parser = new TestParser();
            var variablesFromThisValue = parser.getDefinedVariables(localizedValue);

            if (variablesFromThisValue && variablesFromThisValue.length > 0) {
              assertionVariables.add(...variablesFromThisValue);
            }

            localizedValues.push(localizedValue);
          }

          assertion.variables = Array.from(assertionVariables);

          if (testSuite.filterObject() && testSuite.filterObject().resolve) {
            return yield this.resolveVariablesForAssertionInteraction(assertion, localizedValues, testSuite.filterObject().resolve);
          }

          return localizedValues;
        } else {
          var _localizedValue = testSuite && testSuite.getLocalizedValue(assertion.value) || assertion.value;

          var _parser = new TestParser();

          assertion.variables = _parser.getDefinedVariables(_localizedValue);

          if (testSuite.filterObject() && testSuite.filterObject().resolve) {
            return yield this.resolveVariablesForAssertionInteraction(assertion, _localizedValue, testSuite.filterObject().resolve);
          }

          return _localizedValue;
        }
      });

      function getLocalizedValues(_x33, _x34) {
        return _getLocalizedValues.apply(this, arguments);
      }

      return getLocalizedValues;
    }()
  }, {
    key: "processResponse",
    value: function () {
      var _processResponse = _asyncToGenerator(function* (response, testSuite, context) {
        var interaction = response.interaction; // We check if a filter object is defined
        // If so, it gives the test writer a chance to make changes to the response

        if (testSuite.filterObject() && testSuite.filterObject().onResponse) {
          yield testSuite.filterObject().onResponse(interaction.test, response.json);
        }

        var result = new InteractionResult(interaction);
        var isE2EFirstError = true;

        for (var assertion of interaction.assertions) {
          if (assertion.exit) {
            result = new InteractionResult(interaction, assertion);
            break;
          }

          if (!response.supported(assertion.path)) {
            continue;
          }

          var localizedValues = yield this.getLocalizedValues(testSuite, assertion);
          assertion._value = localizedValues;
          assertion._lenientMode = testSuite.lenientMode;
          var passed = assertion.evaluate(response);

          if (passed) {
            // If this is a goto, stop processing assertions here
            if (assertion.goto) {
              result = new InteractionResult(interaction, assertion);
              break;
            }
          } else if (!assertion.goto) {
            // If it did not pass, and was NOT a goto, then it is a failure
            // We do not consider tests that end in goto statements failures if they do not match
            var error = assertion.toString(response.json, response.errorOnProcess);

            if (testSuite.type === CONSTANTS.TYPE.e2e && !interaction.hasGoto && !interaction.hasExit && !response.errorOnProcess) {
              if (isE2EFirstError) {
                // We save first error data for backward compatibility
                result = new InteractionResult(interaction, assertion, error, response.errorOnProcess);
                isE2EFirstError = false;
              }

              result.addError(error);
            } else {
              if (response.errorOnProcess) {
                result = new InteractionResult(interaction, assertion, response.error, response.errorOnProcess);
              } else {
                result = new InteractionResult(interaction, assertion, error, response.errorOnProcess);
              }

              break;
            }
          }
        }

        if (interaction.assertions && interaction.assertions.length === 0 && response.errorOnProcess) {
          result = new InteractionResult(interaction, undefined, response.error, response.errorOnProcess);
        }

        result.rawResponse = response.json;

        if (testSuite.trace) {
          // eslint-disable-next-line no-console
          console.log(chalk.cyan("Response Envelope:\n" + JSON.stringify(response.json, null, 2)));
        }

        if (testSuite.ignoreExternalErrors && response.errorOnProcess) {
          LoggingErrorHelper.log("info", "bst-test", `ignoreExternalErrors is enabled. Skipping test because it failed with the following error: ${response.errorOnProcess}`);
        }

        var interactionDto = interaction.toDTO(response);
        interactionDto.result = result.toDTO();
        result.interactionDto = interactionDto;
        this.emit("result", undefined, interactionDto, context);
        return result;
      });

      function processResponse(_x35, _x36, _x37) {
        return _processResponse.apply(this, arguments);
      }

      return processResponse;
    }()
  }, {
    key: "parseContents",
    value: function parseContents(fileName, testContents) {
      var parser = new TestParser();
      parser.fileName = fileName;
      parser.load(testContents);
      var suite = parser.parse();
      parser.validateIvrTests(suite);
      return suite;
    } // Method that can be used to print out the request payload, if available
    // TODO - should this be done with an event emitter instead?

  }, {
    key: "filterRequest",
    value: function () {
      var _filterRequest = _asyncToGenerator(function* (interaction, request) {
        interaction.applyExpressions(request); // We check if a filter object is defined
        // If so, it gives the test writer a chance to make changes to the request

        var testSuite = interaction.test.testSuite;

        if (testSuite.filterObject() && testSuite.filterObject().onRequest) {
          yield testSuite.filterObject().onRequest(interaction.test, request);
        }

        if (testSuite.trace) {
          var test = interaction.test; // eslint-disable-next-line no-console

          console.log("File: " + testSuite.shortFileName + " Test: " + test.description + " Utterance: " + interaction.utterance); // eslint-disable-next-line no-console

          console.log(chalk.hex("#ff6633")("Request Envelope:\n" + JSON.stringify(request, null, 2)));
        }
      });

      function filterRequest(_x38, _x39) {
        return _filterRequest.apply(this, arguments);
      }

      return filterRequest;
    }()
  }, {
    key: "handleException",
    value: function handleException(interaction, e) {
      var testSuite = interaction.test.testSuite;

      if (e.message && (e.message.startsWith("Unable to match utterance:") || e.message.startsWith("Interaction model has no intentName named"))) {
        var message = Util.errorMessageWithLine(e.message, testSuite.fileName, interaction.lineNumber);
        return new InteractionResult(interaction, undefined, message);
      } else {
        LoggingErrorHelper.error("bst-test", "Error using bst-test on Node: " + process.version);
        LoggingErrorHelper.error("bst-test", e.stack);

        if (e.type && e.type === "FrameworkError") {
          return new InteractionResult(interaction, undefined, e);
        } else if (e.message) {
          return new InteractionResult(interaction, undefined, e);
        } else {
          return new InteractionResult(interaction, undefined, e.toString());
        }
      }
    }
  }, {
    key: "subscribe",
    value: function subscribe(event, callback) {
      if (event in this._subscribers) {
        this._subscribers[event].push(callback);
      } else {
        this._subscribers[event] = [callback];
      }
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(event) {
      this._subscribers[event] = [];
    }
  }, {
    key: "emit",
    value: function emit(event, error, data, context) {
      if (event in this._subscribers) {
        this._subscribers[event].forEach(subscriber => {
          subscriber(error, data, context);
        });
      }
    }
  }, {
    key: "getInvoker",
    value: function getInvoker(testSuite) {
      var invoker = testSuite.invoker;

      if (invoker) {
        return invoker;
      }

      var type = testSuite.type;
      var platform = testSuite.platform;

      if (type === CONSTANTS.TYPE.e2e) {
        return CONSTANTS.INVOKER.virtualDeviceInvoker;
      } else if (type === CONSTANTS.TYPE.simulation) {
        return CONSTANTS.INVOKER.SMAPIInvoker;
      } else if (type === CONSTANTS.TYPE.unit) {
        if (platform === CONSTANTS.PLATFORM.alexa) {
          return CONSTANTS.INVOKER.virtualAlexaInvoker;
        } else if (platform === CONSTANTS.PLATFORM.google) {
          return CONSTANTS.INVOKER.virtualGoogleAssistantInvoker;
        }
      }

      throw new FrameworkError("valid type and platform must be defined either in the testing.json or the test file itself under the config element");
    }
  }, {
    key: "replaceLocalizedValues",
    value: function replaceLocalizedValues(testSuite) {
      testSuite._description = testSuite.getLocalizedValue(testSuite.description) || testSuite.description;

      for (var test of testSuite.tests) {
        var localizedDescription = testSuite.getLocalizedValue(test.description) || test.description;
        test.description = localizedDescription;

        for (var interaction of test.interactions) {
          var localizedValue = interaction.utterance.split(" ").map(word => {
            return testSuite.getLocalizedValue(word) || word;
          }).join(" ");
          interaction.localizedUtterance = localizedValue;
        }
      }
    }
  }, {
    key: "getSourceExists",
    value: function () {
      var _getSourceExists = _asyncToGenerator(function* (testSuite) {
        var id = testSuite.bespokenProjectId;

        if (!id) {
          return false;
        }

        var urlString = process.env.SOURCE_API_BASE_URL || "https://source-api.bespoken.tools";
        var urlParts = url.parse(urlString);
        var options = {
          headers: {
            "Content-Type": "application/json"
          },
          host: urlParts.hostname,
          method: "GET",
          path: "/v1/getSourceExists?id=" + id,
          port: urlParts.port,
          protocol: urlParts.protocol
        };

        try {
          var response = yield HTTP.get(options);

          if (response.message.statusCode !== 200) {
            LoggingErrorHelper.error("bst-test", "Error getSourceExists" + " Raw Error: " + response.body.trim());
            return false;
          }

          return response.body == "true";
        } catch (error) {
          LoggingErrorHelper.error("Error saving test results: ", error);
          return false;
        }
      });

      function getSourceExists(_x40) {
        return _getSourceExists.apply(this, arguments);
      }

      return getSourceExists;
    }()
  }, {
    key: "saveTestResults",
    value: function () {
      var _saveTestResults = _asyncToGenerator(function* (testResults, testSuite, startTimeTestSuite, getSourceExistsPromise) {
        var {
          bespokenProjectId,
          fileName,
          virtualDeviceToken,
          runId,
          type
        } = testSuite;

        if (type !== "e2e") {
          return;
        }

        if (!bespokenProjectId) {
          return;
        }

        var sourceExists = yield getSourceExistsPromise;

        if (!sourceExists) {
          // eslint-disable-next-line no-console
          console.log(chalk.yellow("The given bespokenProjectId does not exist. The test history won't be saved"));
          return;
        }

        var urlString = process.env.SOURCE_API_BASE_URL || "https://source-api.bespoken.tools";
        var urlParts = url.parse(urlString);
        var options = {
          headers: {
            "Content-Type": "application/json"
          },
          host: urlParts.hostname,
          method: "POST",
          path: "/v2/testResultsHistory",
          port: urlParts.port,
          protocol: urlParts.protocol
        };
        testResults = testResults.map(testResult => {
          var result = testResult.toDTO();

          if (testResult.interactionResults && testResult.interactionResults.length) {
            for (var i = 0; i < testResult.interactionResults.length; i++) {
              if (result && result.test && result.test.interactions && result.test.interactions.length > i) {
                result.test.interactions[i] = testResult.interactionResults[i].interactionDto;
              }
            }
          }

          return result;
        });
        var body = {
          projectId: bespokenProjectId,
          runId,
          testResults,
          testSuite: fileName,
          timestamp: startTimeTestSuite,
          token: virtualDeviceToken
        };

        try {
          var response = yield HTTP.post(options, body);

          if (response.message.statusCode !== 200) {
            LoggingErrorHelper.error("bst-test", "Error saving test results" + " Raw Error: " + response.body.trim());
          }
        } catch (error) {
          LoggingErrorHelper.error("Error saving test results: ", error);
        }
      });

      function saveTestResults(_x41, _x42, _x43, _x44) {
        return _saveTestResults.apply(this, arguments);
      }

      return saveTestResults;
    }()
  }, {
    key: "configuration",
    get: function () {
      return this._config;
    }
  }]);

  return TestRunner;
}();